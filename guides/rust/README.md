# Rust Reference Guide

Reference documentation for Rust development in clau-doom agent-core.

## Key Resources

- [The Rust Programming Language](https://doc.rust-lang.org/book/)
- [Rust by Example](https://doc.rust-lang.org/rust-by-example/)
- [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)
- [Tokio Tutorial](https://tokio.rs/tokio/tutorial)
- [tonic gRPC](https://github.com/hyperium/tonic)

## clau-doom Context

Agent-core is written in Rust for sub-100ms decision making. Key components:
- **Decision engine**: Rule-based strategy execution from MD configuration files
- **RAG client**: OpenSearch kNN query via HTTP (reqwest)
- **Scoring system**: Multi-factor agent performance evaluation (similarity + confidence + recency)
- **DuckDB writer**: Episode and encounter logging via duckdb-rs

Project layout:
```
agent-core/
├── src/
│   ├── strategy/       # Decision engine, rule matching, scoring
│   ├── rag/            # OpenSearch kNN HTTP client
│   ├── game/           # VizDoom state parsing, feature extraction
│   ├── db/             # DuckDB read/write operations
│   └── main.rs         # Entry point, gRPC server
├── Cargo.toml
└── benches/            # Criterion benchmarks
```

## Key Patterns

### Ownership for Game State

Game state flows through the decision pipeline without cloning. Use references for read-only access and owned types only at state boundaries.

```rust
/// Game state owned by the main loop, borrowed by decision engine.
struct GameState {
    health: f32,
    ammo: HashMap<WeaponType, u32>,
    enemies: Vec<Enemy>,
    position: Vec3,
}

/// Decision engine borrows game state immutably.
fn decide_action(state: &GameState, rules: &[Rule]) -> Action {
    // Level 0: Check hardcoded MD rules first (< 1ms)
    if let Some(action) = match_local_rules(state, rules) {
        return action;
    }
    // Level 1: DuckDB cache lookup
    // Level 2: OpenSearch kNN fallback
    // ...
}
```

State transitions use enums to make illegal states unrepresentable:

```rust
enum AgentPhase {
    Exploring { target_area: AreaId },
    Engaging { enemies: Vec<EnemyId>, weapon: WeaponType },
    Retreating { safe_point: Vec3, health: f32 },
    Scavenging { item_type: ItemType },
}
```

### Async with Tokio

Use Tokio for async RAG queries and gRPC communication. The game loop itself runs synchronously for determinism; async is reserved for I/O.

```rust
#[tokio::main]
async fn main() -> Result<()> {
    // gRPC server for orchestrator communication
    let addr = "[::1]:50051".parse()?;
    let agent_service = AgentServiceImpl::new(config);

    Server::builder()
        .add_service(AgentServiceServer::new(agent_service))
        .serve(addr)
        .await?;

    Ok(())
}

/// Async RAG query with timeout.
async fn query_opensearch(
    client: &reqwest::Client,
    embedding: &[f32],
    k: usize,
) -> Result<Vec<StrategyDoc>> {
    let body = serde_json::json!({
        "size": k,
        "query": {
            "knn": {
                "situation_embedding": {
                    "vector": embedding,
                    "k": k
                }
            }
        }
    });

    let resp = client
        .post("http://opensearch:9200/strategies/_search")
        .json(&body)
        .timeout(Duration::from_millis(80)) // Budget: 80ms for search
        .send()
        .await?;

    parse_search_response(resp).await
}
```

### tonic gRPC

Server and client patterns for agent-orchestrator communication. Proto definitions live in `proto/agent.proto`.

```rust
/// Implement the gRPC service trait generated by tonic.
#[tonic::async_trait]
impl AgentService for AgentServiceImpl {
    async fn report_status(
        &self,
        request: Request<StatusRequest>,
    ) -> Result<Response<StatusReply>, Status> {
        let req = request.into_inner();
        let state = self.get_current_state();
        Ok(Response::new(StatusReply {
            agent_id: self.agent_id.clone(),
            generation: self.generation,
            kills: state.kills,
            health: state.health,
            phase: state.phase.to_string(),
        }))
    }

    /// Bidirectional streaming for real-time state updates.
    type WatchStream = ReceiverStream<Result<StateUpdate, Status>>;

    async fn watch(
        &self,
        _request: Request<WatchRequest>,
    ) -> Result<Response<Self::WatchStream>, Status> {
        let (tx, rx) = mpsc::channel(32);
        // Spawn task that pushes state updates
        tokio::spawn(async move {
            // ...stream game state to orchestrator
        });
        Ok(Response::new(ReceiverStream::new(rx)))
    }
}
```

### Error Handling

Use `thiserror` for library-level errors with structured variants. Use `anyhow` for application-level error propagation with `?` chains.

```rust
// Library errors (agent-core crate)
#[derive(Debug, thiserror::Error)]
pub enum AgentError {
    #[error("RAG query failed: {0}")]
    RagError(#[from] reqwest::Error),

    #[error("DuckDB error: {0}")]
    DbError(#[from] duckdb::Error),

    #[error("Strategy not found for situation: {situation:?}")]
    NoStrategy { situation: Vec<String> },

    #[error("Decision timeout: {elapsed_ms}ms > {budget_ms}ms")]
    Timeout { elapsed_ms: u64, budget_ms: u64 },
}

// Application level (main.rs)
use anyhow::{Context, Result};

fn load_agent_config(path: &str) -> Result<AgentConfig> {
    let content = std::fs::read_to_string(path)
        .with_context(|| format!("Failed to read agent MD: {path}"))?;
    parse_md_config(&content)
        .context("Failed to parse agent configuration")
}
```

### Performance

Zero-cost abstractions and avoiding allocations in the hot path are critical for the < 100ms decision budget.

```rust
// Pre-allocate buffers at startup, reuse in game loop.
struct DecisionContext {
    feature_buffer: Vec<f32>,       // Reused each tick
    candidate_buffer: Vec<ScoredDoc>, // Reused each tick
    embedding_cache: LruCache<u64, Vec<f32>>,
}

impl DecisionContext {
    fn decide(&mut self, state: &GameState) -> Action {
        // Clear and reuse buffers instead of allocating new vecs
        self.feature_buffer.clear();
        extract_features(state, &mut self.feature_buffer);

        self.candidate_buffer.clear();
        // ... fill candidates from kNN results
    }
}
```

Benchmark with criterion:

```rust
// benches/decision_bench.rs
use criterion::{criterion_group, criterion_main, Criterion};

fn bench_rule_matching(c: &mut Criterion) {
    let state = mock_game_state();
    let rules = load_test_rules();

    c.bench_function("rule_matching", |b| {
        b.iter(|| match_local_rules(&state, &rules))
    });
}

fn bench_scoring(c: &mut Criterion) {
    let candidates = mock_candidates(10);

    c.bench_function("score_top_k", |b| {
        b.iter(|| score_candidates(&candidates))
    });
}

criterion_group!(benches, bench_rule_matching, bench_scoring);
criterion_main!(benches);
```

### Wilson Score for Confidence

The scoring system uses Wilson score interval lower bound for conservative confidence estimation on strategy documents with small sample sizes.

```rust
/// Wilson score interval lower bound.
/// Conservatively estimates success rate when sample size is small.
fn wilson_lower_bound(successes: u32, total: u32, z: f64) -> f64 {
    if total == 0 {
        return 0.0;
    }
    let n = total as f64;
    let p = successes as f64 / n;
    let z2 = z * z;

    (p + z2 / (2.0 * n) - z * ((p * (1.0 - p) + z2 / (4.0 * n)) / n).sqrt())
        / (1.0 + z2 / n)
}

/// Composite score: similarity(0.4) + confidence(0.4) + recency(0.2)
fn score_document(doc: &StrategyDoc, query_embedding: &[f32]) -> f64 {
    let similarity = cosine_similarity(&doc.embedding, query_embedding);
    let confidence = wilson_lower_bound(
        doc.successes, doc.total_uses, 1.96 // 95% CI
    );
    let recency = recency_decay(doc.last_validated, 0.95); // exponential decay

    0.4 * similarity + 0.4 * confidence + 0.2 * recency
}
```

## Crate Dependencies

| Crate | Purpose |
|-------|---------|
| `tokio` | Async runtime for gRPC and HTTP |
| `tonic` | gRPC server/client |
| `reqwest` | HTTP client for OpenSearch |
| `serde` / `serde_json` | Serialization |
| `duckdb` | Local play log database |
| `thiserror` | Library error types |
| `anyhow` | Application error handling |
| `criterion` | Benchmarking |
| `tracing` | Structured logging |
